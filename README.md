 # 1. Сравнение объектов
```js
let a = { a : 1 }; //создаем объект в ячейке памяти  и присваиваем переменной a
let b = { a : 1 }; //создаем объект в ячейке памяти и присваиваем переменной b
let c = a ; // создаем ссылку на объект a в переменной c

console.log(a === b) // false .. 
//Поскольку объекты находятся в разных ячейках памяти и фактически это разные сущности
console.log(a === c) // true .. 
//переменные ссылаются на один и тот же объект, поскольку переменная 'с' есть ссылка на обьект лежащий в переменной 'а'
console.log(a.a === b.a) // true..
// ключи разных обьектов имеют одинаковое значение
```
____
#  2. foo.x 
```js
var foo = { // объявляем и присваиваем переменную foo обьекту { n : 1 }
    n: 1 
}

var bar = foo // копируем ссылку на обьект переменной foo в новую переменную bar

foo.x = // задаем первой переменной ключ x с его значением после присваивания,
// первая переменная перезаписывается и результат переpаписи мы увидим ниже в переменной bar 
// . т.к переменная bar содержит ссылку на первую переменную foo
    (foo = { // переинициализируем переменную foo. и записываем в нее новый объект. { n : 2}
        n: 2
    })

console.log(foo.x, '           : FOO.X') //в новом обьекте foo ключа x не существует undefined
console.log(bar, '     : BAR') // бар ссылается на старую переменную foo == {n:1,x:{n:2}}
console.log(foo, '             : FOO') // отражает переназначенную переменную foo == {n:2}
```
____
# 3. showPrimes
```js
function showPrimes(n) {
    nextPrime: for (let i = 2; i < n; i++) { // цикл для перебора от 2 до n  обозначаем  меткой nextPrimes ,чтобы пропускать итерации
  
      for (let j = 2; j < i; j++) {
        if (i % j == 0) continue nextPrime; // если i делится без остатка на j, то пропусаем итерацию , выходя на метку nextPrime
      }
  
      console.log( i ); // если оператор continue не пропустил итерацию, значит цикл отработает ее до конца и число является простым, выводим его в консоль
    }
  }
showPrimes(100)
```
____
